/**
 * Define api of apeman-api-sign
 * @function define
 * @param {Object} User - User model
 * @param {Object} UserSign - User sign model
 * @param {Object} [options] - Optional settings
 * @param {boolean} [options.logging] - Enable logger
 * @param {string} [options.passwordSpec] - Spec of password
 * @returns {Object} - API configuration
 */
'use strict';

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var co = require('co');
var assert = require('assert');
var schemas = require('./schemas');
var passwordDigest = require('./digesting/password_digest');
var aslogger = require('aslogger');

var _require = require('apemanerror/buildin'),
    signupProveError = _require.signupProveError,
    signinFailError = _require.signinFailError,
    signinRequiredError = _require.signinRequiredError,
    signInvalidError = _require.signInvalidError;

var spec = require('./spec');

/** @lends api */
function define(User, UserSign) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  assert.ok(User, 'User is required.');
  assert.ok(UserSign, 'UserSign is required.');
  assert.ok(!!(User.$$inherited && User.$$inherited.ApUser), 'UserSign should inherit ApUserSign.');
  assert.ok(!!(UserSign.$$inherited && UserSign.$$inherited.ApUserSign), 'UserSign should inherit ApUserSign.');

  var logger = aslogger({ disabled: !options.logging });
  var digest = passwordDigest(options.passwordSpec);
  var _options$prove = options.prove,
      prove = _options$prove === undefined ? function () {
    return true;
  } : _options$prove;


  var validate = function validate(schemaName, values) {
    return schemas(schemaName).validateToThrow(values, {
      assign: { status: 400 }
    });
  };

  return {
    /**
     * Test the reachability of the api.
     * @method ping
     * @param {string} [pong='pong'] - Pong message to return
     * @returns {string} - Pong message
     */
    ping: function ping(pong) {
      return co(_regenerator2.default.mark(function _callee() {
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt('return', pong || 'pong');

              case 1:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    },


    /**
     * @method signup
     * @param {string} key - User key to signup
     * @param {string} email - User email to signup
     * @param {string} password - User password to signup
     * @param {Object} [options={}] - Optional settings
     * @returns {Promise}
     */
    signup: function signup(key, email, password) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      var s = this;
      var provision = options.provision,
          _options$userAttr = options.userAttr,
          userAttr = _options$userAttr === undefined ? {} : _options$userAttr;

      return co(_regenerator2.default.mark(function _callee2() {
        var proved, user, hashSalt, hash, signs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, kind, _key;

        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                validate('signup', { key: key, email: email, password: password });
                _context2.next = 3;
                return _promise2.default.resolve(prove(provision));

              case 3:
                proved = _context2.sent;

                if (proved) {
                  _context2.next = 6;
                  break;
                }

                throw signupProveError();

              case 6:
                _context2.next = 8;
                return User.create((0, _assign2.default)({ key: key, email: email }, userAttr));

              case 8:
                user = _context2.sent;
                hashSalt = digest.newSalt();
                _context2.next = 12;
                return digest(password, hashSalt);

              case 12:
                hash = _context2.sent;
                signs = [{ kind: 'key', key: key }, { kind: 'email', key: email }].filter(function (sign) {
                  return !!sign.key;
                });
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context2.prev = 17;
                _iterator = (0, _getIterator3.default)(signs);

              case 19:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context2.next = 26;
                  break;
                }

                _step$value = _step.value, kind = _step$value.kind, _key = _step$value.key;
                _context2.next = 23;
                return UserSign.create({
                  kind: kind,
                  key: _key,
                  hash: hash,
                  hashSalt: hashSalt,
                  signupAt: new Date(),
                  userId: user.id
                });

              case 23:
                _iteratorNormalCompletion = true;
                _context2.next = 19;
                break;

              case 26:
                _context2.next = 32;
                break;

              case 28:
                _context2.prev = 28;
                _context2.t0 = _context2['catch'](17);
                _didIteratorError = true;
                _iteratorError = _context2.t0;

              case 32:
                _context2.prev = 32;
                _context2.prev = 33;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 35:
                _context2.prev = 35;

                if (!_didIteratorError) {
                  _context2.next = 38;
                  break;
                }

                throw _iteratorError;

              case 38:
                return _context2.finish(35);

              case 39:
                return _context2.finish(32);

              case 40:
                return _context2.abrupt('return', s.signin(key, password));

              case 41:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this, [[17, 28, 32, 40], [33,, 35, 39]]);
      }));
    },


    /**
     * Do sign in
     * @method signin
     * @param {string} key - User key or email to signup
     * @param {string} password - User password
     * @returns {Promise}
     */
    signin: function signin(key, password) {
      var s = this;
      var session = s.session;

      return co(_regenerator2.default.mark(function _callee3() {
        var userSign, hash, valid, user;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                validate('signin', { key: key, password: password });
                _context3.next = 3;
                return UserSign.findOne({
                  where: { key: key },
                  include: [UserSign.getRef('user')]
                });

              case 3:
                userSign = _context3.sent;

                if (userSign) {
                  _context3.next = 6;
                  break;
                }

                throw signinFailError();

              case 6:
                _context3.next = 8;
                return digest(password, userSign.hashSalt);

              case 8:
                hash = _context3.sent;
                valid = hash === userSign.hash;

                if (valid) {
                  _context3.next = 12;
                  break;
                }

                throw signinFailError();

              case 12:
                user = userSign.user;

                if (user) {
                  _context3.next = 15;
                  break;
                }

                throw signInvalidError();

              case 15:
                session.signed = define.formatSigned(user, userSign);
                _context3.next = 18;
                return s.signget();

              case 18:
                return _context3.abrupt('return', _context3.sent);

              case 19:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
    },


    /**
     * Get signing data
     * @method signget
     * @returns {Promise}
     */
    signget: function signget() {
      var s = this;
      var session = s.session;
      var signed = session.signed;

      return co(_regenerator2.default.mark(function _callee4() {
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt('return', signed);

              case 1:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
    },


    /**
     * Modify sign data
     * @method signmod
     * @param {object} keys - Sign keys to update
     * @param {string} [password] - Password to update
     * @returns {Promise}
     */
    signmod: function signmod(keys, password) {
      var s = this;
      var session = s.session;
      var signed = session.signed;

      if (!signed) {
        throw signinRequiredError();
      }
      var userId = signed.id;
      return co(_regenerator2.default.mark(function _callee5() {
        var user, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _kind, _value, userSign, patch, changed, kind, value;

        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return User.findById(userId);

              case 2:
                user = _context5.sent;
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context5.prev = 6;
                _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(keys));

              case 8:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context5.next = 30;
                  break;
                }

                _kind = _step2.value;
                _value = keys[_kind];
                _context5.next = 13;
                return UserSign.findOne({
                  where: { kind: _kind, userId: userId }
                });

              case 13:
                userSign = _context5.sent;
                patch = { key: keys[_kind] };

                if (!password) {
                  _context5.next = 19;
                  break;
                }

                _context5.next = 18;
                return digest(password, userSign.hashSalt);

              case 18:
                patch.hash = _context5.sent;

              case 19:
                changed = user[_kind] !== _value;

                if (!changed) {
                  _context5.next = 23;
                  break;
                }

                _context5.next = 23;
                return user.update((0, _defineProperty3.default)({}, _kind, _value));

              case 23:
                _context5.next = 25;
                return userSign.update(patch);

              case 25:
                userSign = _context5.sent;

                if (signed.sign.kind === _kind) {
                  signed.sign = userSign;
                }

              case 27:
                _iteratorNormalCompletion2 = true;
                _context5.next = 8;
                break;

              case 30:
                _context5.next = 36;
                break;

              case 32:
                _context5.prev = 32;
                _context5.t0 = _context5['catch'](6);
                _didIteratorError2 = true;
                _iteratorError2 = _context5.t0;

              case 36:
                _context5.prev = 36;
                _context5.prev = 37;

                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }

              case 39:
                _context5.prev = 39;

                if (!_didIteratorError2) {
                  _context5.next = 42;
                  break;
                }

                throw _iteratorError2;

              case 42:
                return _context5.finish(39);

              case 43:
                return _context5.finish(36);

              case 44:
                if (!password) {
                  _context5.next = 52;
                  break;
                }

                kind = signed.sign.kind;
                value = keys[kind];
                _context5.next = 49;
                return s.signin(value, password);

              case 49:
                return _context5.abrupt('return', _context5.sent);

              case 52:
                _context5.next = 54;
                return s.signget();

              case 54:
                return _context5.abrupt('return', _context5.sent);

              case 55:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this, [[6, 32, 36, 44], [37,, 39, 43]]);
      }));
    },


    /**
     * Do signout
     * @method signout
     * @returns {Promise}
     */
    signout: function signout() {
      var s = this;
      var session = s.session;

      return co(_regenerator2.default.mark(function _callee6() {
        var _session$signed, signed, sign, userSign;

        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _session$signed = session.signed, signed = _session$signed === undefined ? {} : _session$signed;

                delete session.signed;
                sign = signed.sign;

                if (sign) {
                  _context6.next = 5;
                  break;
                }

                return _context6.abrupt('return');

              case 5:
                _context6.next = 7;
                return UserSign.findById(sign.id);

              case 7:
                userSign = _context6.sent;

                if (userSign) {
                  _context6.next = 10;
                  break;
                }

                return _context6.abrupt('return', null);

              case 10:
                _context6.next = 12;
                return userSign.update({
                  signoutAt: new Date()
                });

              case 12:
                return _context6.abrupt('return', signed);

              case 13:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
    },


    /**
     * Delete sign data
     * @method signdel
     * @returns {Promise}
     */
    signdel: function signdel() {
      var s = this;
      var session = s.session;
      var signed = session.signed;

      var hasSign = signed && signed.hasOwnProperty('id');
      if (!hasSign) {
        throw signinRequiredError();
      }
      var userId = signed.id;

      return co(_regenerator2.default.mark(function _callee7() {
        var userSigns, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, userSign, user;

        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return UserSign.findAll({
                  where: { userId: userId }
                });

              case 2:
                userSigns = _context7.sent;
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context7.prev = 6;
                _iterator3 = (0, _getIterator3.default)(userSigns);

              case 8:
                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                  _context7.next = 15;
                  break;
                }

                userSign = _step3.value;
                _context7.next = 12;
                return userSign.destroy();

              case 12:
                _iteratorNormalCompletion3 = true;
                _context7.next = 8;
                break;

              case 15:
                _context7.next = 21;
                break;

              case 17:
                _context7.prev = 17;
                _context7.t0 = _context7['catch'](6);
                _didIteratorError3 = true;
                _iteratorError3 = _context7.t0;

              case 21:
                _context7.prev = 21;
                _context7.prev = 22;

                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }

              case 24:
                _context7.prev = 24;

                if (!_didIteratorError3) {
                  _context7.next = 27;
                  break;
                }

                throw _iteratorError3;

              case 27:
                return _context7.finish(24);

              case 28:
                return _context7.finish(21);

              case 29:
                _context7.next = 31;
                return User.findById(userId);

              case 31:
                user = _context7.sent;
                _context7.next = 34;
                return user.destroy();

              case 34:
                return _context7.abrupt('return', s.signout());

              case 35:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this, [[6, 17, 21, 29], [22,, 24, 28]]);
      }));
    },


    /**
     * Check password is valid
     * @method check
     * @param {string} password
     * @returns {Promise}
     */
    check: function check(password) {
      var s = this;
      var session = s.session;

      return co(_regenerator2.default.mark(function _callee8() {
        var signed, hasSign, sign, hash;
        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                signed = session.signed;
                hasSign = signed && signed.hasOwnProperty('id');

                if (hasSign) {
                  _context8.next = 4;
                  break;
                }

                throw signinRequiredError();

              case 4:
                sign = signed.sign;
                _context8.next = 7;
                return digest(password, sign.hashSalt);

              case 7:
                hash = _context8.sent;
                return _context8.abrupt('return', hash === sign.hash);

              case 9:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
    },


    /**
     * A hook which runs before method invoked
     * @param {string} methodName - Name of method to invoke
     * @param {Array} params - Prams for invocation
     * @returns {Promise}
     */
    $before: function $before(methodName, params) {
      var s = this;
      var session = s.session;

      if (!session) {
        throw new Error('Session not found. You need to add apeman-middleware-session to $middlewares.');
      }

      var state = s.state;

      return co(_regenerator2.default.mark(function _callee9() {
        return _regenerator2.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                state.invokedAt = new Date();
                logger.info(methodName + ' started...');

              case 2:
              case 'end':
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));
    },

    /**
     * A hook which runs after method invoked
     * @param {string} methodName - Name of method to invoke
     * @param {Array} params - Prams for invocation
     * @param {?*} returns - Return values
     * @returns {Promise}
     */
    $after: function $after(methodName, params, returns) {
      var s = this;
      var state = s.state;

      return co(_regenerator2.default.mark(function _callee10() {
        var took;
        return _regenerator2.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                took = new Date() - state.invokedAt;

                logger.info('...' + methodName + ' done! (' + took + 'ms)');

              case 2:
              case 'end':
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));
    },

    /**
     * Method specifications
     */
    $spec: spec
  };
}

(0, _assign2.default)(define, {
  formatSigned: function formatSigned(user, userSign) {
    var sign = userSign.toJSON();
    delete sign.user;
    return (0, _assign2.default)({}, user.toJSON(), { sign: sign });
  }
});

module.exports = define;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlZmluZS5qcyJdLCJuYW1lcyI6WyJjbyIsInJlcXVpcmUiLCJhc3NlcnQiLCJzY2hlbWFzIiwicGFzc3dvcmREaWdlc3QiLCJhc2xvZ2dlciIsInNpZ251cFByb3ZlRXJyb3IiLCJzaWduaW5GYWlsRXJyb3IiLCJzaWduaW5SZXF1aXJlZEVycm9yIiwic2lnbkludmFsaWRFcnJvciIsInNwZWMiLCJkZWZpbmUiLCJVc2VyIiwiVXNlclNpZ24iLCJvcHRpb25zIiwib2siLCIkJGluaGVyaXRlZCIsIkFwVXNlciIsIkFwVXNlclNpZ24iLCJsb2dnZXIiLCJkaXNhYmxlZCIsImxvZ2dpbmciLCJkaWdlc3QiLCJwYXNzd29yZFNwZWMiLCJwcm92ZSIsInZhbGlkYXRlIiwic2NoZW1hTmFtZSIsInZhbHVlcyIsInZhbGlkYXRlVG9UaHJvdyIsImFzc2lnbiIsInN0YXR1cyIsInBpbmciLCJwb25nIiwic2lnbnVwIiwia2V5IiwiZW1haWwiLCJwYXNzd29yZCIsInMiLCJwcm92aXNpb24iLCJ1c2VyQXR0ciIsInJlc29sdmUiLCJwcm92ZWQiLCJjcmVhdGUiLCJ1c2VyIiwiaGFzaFNhbHQiLCJuZXdTYWx0IiwiaGFzaCIsInNpZ25zIiwia2luZCIsImZpbHRlciIsInNpZ24iLCJzaWdudXBBdCIsIkRhdGUiLCJ1c2VySWQiLCJpZCIsInNpZ25pbiIsInNlc3Npb24iLCJmaW5kT25lIiwid2hlcmUiLCJpbmNsdWRlIiwiZ2V0UmVmIiwidXNlclNpZ24iLCJ2YWxpZCIsInNpZ25lZCIsImZvcm1hdFNpZ25lZCIsInNpZ25nZXQiLCJzaWdubW9kIiwia2V5cyIsImZpbmRCeUlkIiwidmFsdWUiLCJwYXRjaCIsImNoYW5nZWQiLCJ1cGRhdGUiLCJzaWdub3V0Iiwic2lnbm91dEF0Iiwic2lnbmRlbCIsImhhc1NpZ24iLCJoYXNPd25Qcm9wZXJ0eSIsImZpbmRBbGwiLCJ1c2VyU2lnbnMiLCJkZXN0cm95IiwiY2hlY2siLCIkYmVmb3JlIiwibWV0aG9kTmFtZSIsInBhcmFtcyIsIkVycm9yIiwic3RhdGUiLCJpbnZva2VkQXQiLCJpbmZvIiwiJGFmdGVyIiwicmV0dXJucyIsInRvb2siLCIkc3BlYyIsInRvSlNPTiIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxLQUFLQyxRQUFRLElBQVIsQ0FBWDtBQUNBLElBQU1DLFNBQVNELFFBQVEsUUFBUixDQUFmO0FBQ0EsSUFBTUUsVUFBVUYsUUFBUSxXQUFSLENBQWhCO0FBQ0EsSUFBTUcsaUJBQWlCSCxRQUFRLDZCQUFSLENBQXZCO0FBQ0EsSUFBTUksV0FBV0osUUFBUSxVQUFSLENBQWpCOztlQU1JQSxRQUFRLHFCQUFSLEM7SUFKRkssZ0IsWUFBQUEsZ0I7SUFDQUMsZSxZQUFBQSxlO0lBQ0FDLG1CLFlBQUFBLG1CO0lBQ0FDLGdCLFlBQUFBLGdCOztBQUdGLElBQU1DLE9BQU9ULFFBQVEsUUFBUixDQUFiOztBQUVBO0FBQ0EsU0FBU1UsTUFBVCxDQUFpQkMsSUFBakIsRUFBdUJDLFFBQXZCLEVBQStDO0FBQUEsTUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUM3Q1osU0FBT2EsRUFBUCxDQUFVSCxJQUFWLEVBQWdCLG1CQUFoQjtBQUNBVixTQUFPYSxFQUFQLENBQVVGLFFBQVYsRUFBb0IsdUJBQXBCO0FBQ0FYLFNBQU9hLEVBQVAsQ0FBVSxDQUFDLEVBQUVILEtBQUtJLFdBQUwsSUFBb0JKLEtBQUtJLFdBQUwsQ0FBaUJDLE1BQXZDLENBQVgsRUFBMkQscUNBQTNEO0FBQ0FmLFNBQU9hLEVBQVAsQ0FBVSxDQUFDLEVBQUVGLFNBQVNHLFdBQVQsSUFBd0JILFNBQVNHLFdBQVQsQ0FBcUJFLFVBQS9DLENBQVgsRUFBdUUscUNBQXZFOztBQUVBLE1BQUlDLFNBQVNkLFNBQVMsRUFBRWUsVUFBVSxDQUFDTixRQUFRTyxPQUFyQixFQUFULENBQWI7QUFDQSxNQUFJQyxTQUFTbEIsZUFBZVUsUUFBUVMsWUFBdkIs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RUFBUDtBQUlELEtBM1BJOztBQTRQTDs7O0FBR0FDLFdBQU9sRjtBQS9QRixHQUFQO0FBaVFEOztBQUVELHNCQUFjQyxNQUFkLEVBQXNCO0FBQ3BCcUQsY0FEb0Isd0JBQ05yQixJQURNLEVBQ0FrQixRQURBLEVBQ1U7QUFDNUIsUUFBSVgsT0FBT1csU0FBU2dDLE1BQVQsRUFBWDtBQUNBLFdBQU8zQyxLQUFLUCxJQUFaO0FBQ0EsV0FBTyxzQkFBYyxFQUFkLEVBQWtCQSxLQUFLa0QsTUFBTCxFQUFsQixFQUFpQyxFQUFFM0MsVUFBRixFQUFqQyxDQUFQO0FBQ0Q7QUFMbUIsQ0FBdEI7O0FBUUE0QyxPQUFPQyxPQUFQLEdBQWlCcEYsTUFBakIiLCJmaWxlIjoiZGVmaW5lLmpzIiwic291cmNlUm9vdCI6ImxpYiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVmaW5lIGFwaSBvZiBhcGVtYW4tYXBpLXNpZ25cbiAqIEBmdW5jdGlvbiBkZWZpbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBVc2VyIC0gVXNlciBtb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IFVzZXJTaWduIC0gVXNlciBzaWduIG1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgc2V0dGluZ3NcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubG9nZ2luZ10gLSBFbmFibGUgbG9nZ2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGFzc3dvcmRTcGVjXSAtIFNwZWMgb2YgcGFzc3dvcmRcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQVBJIGNvbmZpZ3VyYXRpb25cbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvID0gcmVxdWlyZSgnY28nKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHNjaGVtYXMgPSByZXF1aXJlKCcuL3NjaGVtYXMnKVxuY29uc3QgcGFzc3dvcmREaWdlc3QgPSByZXF1aXJlKCcuL2RpZ2VzdGluZy9wYXNzd29yZF9kaWdlc3QnKVxuY29uc3QgYXNsb2dnZXIgPSByZXF1aXJlKCdhc2xvZ2dlcicpXG5jb25zdCB7XG4gIHNpZ251cFByb3ZlRXJyb3IsXG4gIHNpZ25pbkZhaWxFcnJvcixcbiAgc2lnbmluUmVxdWlyZWRFcnJvcixcbiAgc2lnbkludmFsaWRFcnJvclxufSA9IHJlcXVpcmUoJ2FwZW1hbmVycm9yL2J1aWxkaW4nKVxuXG5jb25zdCBzcGVjID0gcmVxdWlyZSgnLi9zcGVjJylcblxuLyoqIEBsZW5kcyBhcGkgKi9cbmZ1bmN0aW9uIGRlZmluZSAoVXNlciwgVXNlclNpZ24sIG9wdGlvbnMgPSB7fSkge1xuICBhc3NlcnQub2soVXNlciwgJ1VzZXIgaXMgcmVxdWlyZWQuJylcbiAgYXNzZXJ0Lm9rKFVzZXJTaWduLCAnVXNlclNpZ24gaXMgcmVxdWlyZWQuJylcbiAgYXNzZXJ0Lm9rKCEhKFVzZXIuJCRpbmhlcml0ZWQgJiYgVXNlci4kJGluaGVyaXRlZC5BcFVzZXIpLCAnVXNlclNpZ24gc2hvdWxkIGluaGVyaXQgQXBVc2VyU2lnbi4nKVxuICBhc3NlcnQub2soISEoVXNlclNpZ24uJCRpbmhlcml0ZWQgJiYgVXNlclNpZ24uJCRpbmhlcml0ZWQuQXBVc2VyU2lnbiksICdVc2VyU2lnbiBzaG91bGQgaW5oZXJpdCBBcFVzZXJTaWduLicpXG5cbiAgbGV0IGxvZ2dlciA9IGFzbG9nZ2VyKHsgZGlzYWJsZWQ6ICFvcHRpb25zLmxvZ2dpbmcgfSlcbiAgbGV0IGRpZ2VzdCA9IHBhc3N3b3JkRGlnZXN0KG9wdGlvbnMucGFzc3dvcmRTcGVjKVxuICBsZXQgeyBwcm92ZSA9ICgpID0+IHRydWUgfSA9IG9wdGlvbnNcblxuICBsZXQgdmFsaWRhdGUgPSAoc2NoZW1hTmFtZSwgdmFsdWVzKSA9PiBzY2hlbWFzKHNjaGVtYU5hbWUpLnZhbGlkYXRlVG9UaHJvdyh2YWx1ZXMsIHtcbiAgICBhc3NpZ246IHsgc3RhdHVzOiA0MDAgfVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGVzdCB0aGUgcmVhY2hhYmlsaXR5IG9mIHRoZSBhcGkuXG4gICAgICogQG1ldGhvZCBwaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwb25nPSdwb25nJ10gLSBQb25nIG1lc3NhZ2UgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBQb25nIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBwaW5nIChwb25nKSB7XG4gICAgICByZXR1cm4gY28oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIHJldHVybiBwb25nIHx8ICdwb25nJ1xuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBzaWdudXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVXNlciBrZXkgdG8gc2lnbnVwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsIC0gVXNlciBlbWFpbCB0byBzaWdudXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkIHRvIHNpZ251cFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25hbCBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNpZ251cCAoa2V5LCBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgY29uc3QgcyA9IHRoaXNcbiAgICAgIGxldCB7IHByb3Zpc2lvbiwgdXNlckF0dHIgPSB7fSB9ID0gb3B0aW9uc1xuICAgICAgcmV0dXJuIGNvKGZ1bmN0aW9uICogKCkge1xuICAgICAgICB2YWxpZGF0ZSgnc2lnbnVwJywgeyBrZXksIGVtYWlsLCBwYXNzd29yZCB9KVxuICAgICAgICBsZXQgcHJvdmVkID0geWllbGQgUHJvbWlzZS5yZXNvbHZlKHByb3ZlKHByb3Zpc2lvbikpXG4gICAgICAgIGlmICghcHJvdmVkKSB7XG4gICAgICAgICAgdGhyb3cgc2lnbnVwUHJvdmVFcnJvcigpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZXIgPSB5aWVsZCBVc2VyLmNyZWF0ZShPYmplY3QuYXNzaWduKHsga2V5LCBlbWFpbCB9LCB1c2VyQXR0cikpXG4gICAgICAgIGxldCBoYXNoU2FsdCA9IGRpZ2VzdC5uZXdTYWx0KClcbiAgICAgICAgbGV0IGhhc2ggPSB5aWVsZCBkaWdlc3QocGFzc3dvcmQsIGhhc2hTYWx0KVxuICAgICAgICBsZXQgc2lnbnMgPSBbXG4gICAgICAgICAgeyBraW5kOiAna2V5Jywga2V5OiBrZXkgfSxcbiAgICAgICAgICB7IGtpbmQ6ICdlbWFpbCcsIGtleTogZW1haWwgfVxuICAgICAgICBdLmZpbHRlcigoc2lnbikgPT4gISFzaWduLmtleSlcbiAgICAgICAgZm9yIChsZXQgeyBraW5kLCBrZXkgfSBvZiBzaWducykge1xuICAgICAgICAgIHlpZWxkIFVzZXJTaWduLmNyZWF0ZSh7XG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIGhhc2hTYWx0LFxuICAgICAgICAgICAgc2lnbnVwQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB1c2VySWQ6IHVzZXIuaWRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzLnNpZ25pbihrZXksIHBhc3N3b3JkKVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRG8gc2lnbiBpblxuICAgICAqIEBtZXRob2Qgc2lnbmluXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFVzZXIga2V5IG9yIGVtYWlsIHRvIHNpZ251cFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIgcGFzc3dvcmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzaWduaW4gKGtleSwgcGFzc3dvcmQpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgICBsZXQgeyBzZXNzaW9uIH0gPSBzXG4gICAgICByZXR1cm4gY28oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIHZhbGlkYXRlKCdzaWduaW4nLCB7IGtleSwgcGFzc3dvcmQgfSlcbiAgICAgICAgbGV0IHVzZXJTaWduID0geWllbGQgVXNlclNpZ24uZmluZE9uZSh7XG4gICAgICAgICAgd2hlcmU6IHsga2V5IH0sXG4gICAgICAgICAgaW5jbHVkZTogWyBVc2VyU2lnbi5nZXRSZWYoJ3VzZXInKSBdXG4gICAgICAgIH0pXG4gICAgICAgIGlmICghdXNlclNpZ24pIHtcbiAgICAgICAgICB0aHJvdyBzaWduaW5GYWlsRXJyb3IoKVxuICAgICAgICB9XG4gICAgICAgIGxldCBoYXNoID0geWllbGQgZGlnZXN0KHBhc3N3b3JkLCB1c2VyU2lnbi5oYXNoU2FsdClcbiAgICAgICAgbGV0IHZhbGlkID0gaGFzaCA9PT0gdXNlclNpZ24uaGFzaFxuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgc2lnbmluRmFpbEVycm9yKClcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyB1c2VyIH0gPSB1c2VyU2lnblxuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICB0aHJvdyBzaWduSW52YWxpZEVycm9yKClcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLnNpZ25lZCA9IGRlZmluZS5mb3JtYXRTaWduZWQodXNlciwgdXNlclNpZ24pXG4gICAgICAgIHJldHVybiB5aWVsZCBzLnNpZ25nZXQoKVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNpZ25pbmcgZGF0YVxuICAgICAqIEBtZXRob2Qgc2lnbmdldFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHNpZ25nZXQgKCkge1xuICAgICAgY29uc3QgcyA9IHRoaXNcbiAgICAgIGxldCB7IHNlc3Npb24gfSA9IHNcbiAgICAgIGxldCB7IHNpZ25lZCB9ID0gc2Vzc2lvblxuICAgICAgcmV0dXJuIGNvKGZ1bmN0aW9uICogKCkge1xuICAgICAgICByZXR1cm4gc2lnbmVkXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgc2lnbiBkYXRhXG4gICAgICogQG1ldGhvZCBzaWdubW9kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGtleXMgLSBTaWduIGtleXMgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXNzd29yZF0gLSBQYXNzd29yZCB0byB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzaWdubW9kIChrZXlzLCBwYXNzd29yZCkge1xuICAgICAgY29uc3QgcyA9IHRoaXNcbiAgICAgIGxldCB7IHNlc3Npb24gfSA9IHNcbiAgICAgIGxldCB7IHNpZ25lZCB9ID0gc2Vzc2lvblxuICAgICAgaWYgKCFzaWduZWQpIHtcbiAgICAgICAgdGhyb3cgc2lnbmluUmVxdWlyZWRFcnJvcigpXG4gICAgICB9XG4gICAgICBsZXQgdXNlcklkID0gc2lnbmVkLmlkXG4gICAgICByZXR1cm4gY28oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCB1c2VyID0geWllbGQgVXNlci5maW5kQnlJZCh1c2VySWQpXG4gICAgICAgIGZvciAobGV0IGtpbmQgb2YgT2JqZWN0LmtleXMoa2V5cykpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBrZXlzWyBraW5kIF1cbiAgICAgICAgICBsZXQgdXNlclNpZ24gPSB5aWVsZCBVc2VyU2lnbi5maW5kT25lKHtcbiAgICAgICAgICAgIHdoZXJlOiB7IGtpbmQsIHVzZXJJZCB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGxldCBwYXRjaCA9IHsga2V5OiBrZXlzWyBraW5kIF0gfVxuICAgICAgICAgIGlmIChwYXNzd29yZCkge1xuICAgICAgICAgICAgcGF0Y2guaGFzaCA9IHlpZWxkIGRpZ2VzdChwYXNzd29yZCwgdXNlclNpZ24uaGFzaFNhbHQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjaGFuZ2VkID0gdXNlclsga2luZCBdICE9PSB2YWx1ZVxuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB5aWVsZCB1c2VyLnVwZGF0ZSh7IFtraW5kXTogdmFsdWUgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdXNlclNpZ24gPSB5aWVsZCB1c2VyU2lnbi51cGRhdGUocGF0Y2gpXG4gICAgICAgICAgaWYgKHNpZ25lZC5zaWduLmtpbmQgPT09IGtpbmQpIHtcbiAgICAgICAgICAgIHNpZ25lZC5zaWduID0gdXNlclNpZ25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICAgICAgbGV0IHsga2luZCB9ID0gc2lnbmVkLnNpZ25cbiAgICAgICAgICBsZXQgdmFsdWUgPSBrZXlzWyBraW5kIF1cbiAgICAgICAgICByZXR1cm4geWllbGQgcy5zaWduaW4odmFsdWUsIHBhc3N3b3JkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB5aWVsZCBzLnNpZ25nZXQoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEbyBzaWdub3V0XG4gICAgICogQG1ldGhvZCBzaWdub3V0XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgc2lnbm91dCAoKSB7XG4gICAgICBjb25zdCBzID0gdGhpc1xuICAgICAgbGV0IHsgc2Vzc2lvbiB9ID0gc1xuICAgICAgcmV0dXJuIGNvKGZ1bmN0aW9uICogKCkge1xuICAgICAgICBsZXQgeyBzaWduZWQgPSB7fSB9ID0gc2Vzc2lvblxuICAgICAgICBkZWxldGUgc2Vzc2lvbi5zaWduZWRcbiAgICAgICAgbGV0IHsgc2lnbiB9ID0gc2lnbmVkXG4gICAgICAgIGlmICghc2lnbikge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGxldCB1c2VyU2lnbiA9IHlpZWxkIFVzZXJTaWduLmZpbmRCeUlkKHNpZ24uaWQpXG4gICAgICAgIGlmICghdXNlclNpZ24pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHVzZXJTaWduLnVwZGF0ZSh7XG4gICAgICAgICAgc2lnbm91dEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBzaWduZWRcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBzaWduIGRhdGFcbiAgICAgKiBAbWV0aG9kIHNpZ25kZWxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzaWduZGVsICgpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgICBsZXQgeyBzZXNzaW9uIH0gPSBzXG4gICAgICBsZXQgeyBzaWduZWQgfSA9IHNlc3Npb25cbiAgICAgIGxldCBoYXNTaWduID0gc2lnbmVkICYmIHNpZ25lZC5oYXNPd25Qcm9wZXJ0eSgnaWQnKVxuICAgICAgaWYgKCFoYXNTaWduKSB7XG4gICAgICAgIHRocm93IHNpZ25pblJlcXVpcmVkRXJyb3IoKVxuICAgICAgfVxuICAgICAgbGV0IHsgaWQ6IHVzZXJJZCB9ID0gc2lnbmVkXG4gICAgICByZXR1cm4gY28oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCB1c2VyU2lnbnMgPSB5aWVsZCBVc2VyU2lnbi5maW5kQWxsKHtcbiAgICAgICAgICB3aGVyZTogeyB1c2VySWQgfVxuICAgICAgICB9KVxuICAgICAgICBmb3IgKGxldCB1c2VyU2lnbiBvZiB1c2VyU2lnbnMpIHtcbiAgICAgICAgICB5aWVsZCB1c2VyU2lnbi5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXNlciA9IHlpZWxkIFVzZXIuZmluZEJ5SWQodXNlcklkKVxuICAgICAgICB5aWVsZCB1c2VyLmRlc3Ryb3koKVxuICAgICAgICByZXR1cm4gcy5zaWdub3V0KClcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHBhc3N3b3JkIGlzIHZhbGlkXG4gICAgICogQG1ldGhvZCBjaGVja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGNoZWNrIChwYXNzd29yZCkge1xuICAgICAgY29uc3QgcyA9IHRoaXNcbiAgICAgIGxldCB7IHNlc3Npb24gfSA9IHNcbiAgICAgIHJldHVybiBjbyhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IHsgc2lnbmVkIH0gPSBzZXNzaW9uXG4gICAgICAgIGxldCBoYXNTaWduID0gc2lnbmVkICYmIHNpZ25lZC5oYXNPd25Qcm9wZXJ0eSgnaWQnKVxuICAgICAgICBpZiAoIWhhc1NpZ24pIHtcbiAgICAgICAgICB0aHJvdyBzaWduaW5SZXF1aXJlZEVycm9yKClcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBzaWduIH0gPSBzaWduZWRcbiAgICAgICAgbGV0IGhhc2ggPSB5aWVsZCBkaWdlc3QocGFzc3dvcmQsIHNpZ24uaGFzaFNhbHQpXG4gICAgICAgIHJldHVybiBoYXNoID09PSBzaWduLmhhc2hcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgaG9vayB3aGljaCBydW5zIGJlZm9yZSBtZXRob2QgaW52b2tlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gTmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIC0gUHJhbXMgZm9yIGludm9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICAkYmVmb3JlIChtZXRob2ROYW1lLCBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgICBsZXQgeyBzZXNzaW9uIH0gPSBzXG4gICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIG5vdCBmb3VuZC4gWW91IG5lZWQgdG8gYWRkIGFwZW1hbi1taWRkbGV3YXJlLXNlc3Npb24gdG8gJG1pZGRsZXdhcmVzLicpXG4gICAgICB9XG5cbiAgICAgIGxldCB7IHN0YXRlIH0gPSBzXG4gICAgICByZXR1cm4gY28oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIHN0YXRlLmludm9rZWRBdCA9IG5ldyBEYXRlKClcbiAgICAgICAgbG9nZ2VyLmluZm8oYCR7bWV0aG9kTmFtZX0gc3RhcnRlZC4uLmApXG4gICAgICB9KVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQSBob29rIHdoaWNoIHJ1bnMgYWZ0ZXIgbWV0aG9kIGludm9rZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSAtIE5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyAtIFByYW1zIGZvciBpbnZvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/Kn0gcmV0dXJucyAtIFJldHVybiB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICAkYWZ0ZXIgKG1ldGhvZE5hbWUsIHBhcmFtcywgcmV0dXJucykge1xuICAgICAgY29uc3QgcyA9IHRoaXNcbiAgICAgIGxldCB7IHN0YXRlIH0gPSBzXG4gICAgICByZXR1cm4gY28oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCB0b29rID0gbmV3IERhdGUoKSAtIHN0YXRlLmludm9rZWRBdFxuICAgICAgICBsb2dnZXIuaW5mbyhgLi4uJHttZXRob2ROYW1lfSBkb25lISAoJHt0b29rfW1zKWApXG4gICAgICB9KVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHNwZWNpZmljYXRpb25zXG4gICAgICovXG4gICAgJHNwZWM6IHNwZWNcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKGRlZmluZSwge1xuICBmb3JtYXRTaWduZWQgKHVzZXIsIHVzZXJTaWduKSB7XG4gICAgbGV0IHNpZ24gPSB1c2VyU2lnbi50b0pTT04oKVxuICAgIGRlbGV0ZSBzaWduLnVzZXJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdXNlci50b0pTT04oKSwgeyBzaWduIH0pXG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lXG4iXX0=