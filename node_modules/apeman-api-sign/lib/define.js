/**
 * Define api of apeman-api-sign
 * @function define
 * @param {Object} User - User model
 * @param {Object} UserSign - User sign model
 * @param {Object} [options] - Optional settings
 * @param {boolean} [options.logging] - Enable logger
 * @param {string} [options.passwordSpec] - Spec of password
 * @returns {Object} - API configuration
 */
'use strict'

const co = require('co')
const assert = require('assert')
const schemas = require('./schemas')
const passwordDigest = require('./digesting/password_digest')
const aslogger = require('aslogger')
const {
  signupProveError,
  signinFailError,
  signinRequiredError,
  signInvalidError
} = require('apemanerror/buildin')

const spec = require('./spec')

/** @lends api */
function define (User, UserSign, options = {}) {
  assert.ok(User, 'User is required.')
  assert.ok(UserSign, 'UserSign is required.')
  assert.ok(!!(User.$$inherited && User.$$inherited.ApUser), 'UserSign should inherit ApUserSign.')
  assert.ok(!!(UserSign.$$inherited && UserSign.$$inherited.ApUserSign), 'UserSign should inherit ApUserSign.')

  let logger = aslogger({ disabled: !options.logging })
  let digest = passwordDigest(options.passwordSpec)
  let { prove = () => true } = options

  let validate = (schemaName, values) => schemas(schemaName).validateToThrow(values, {
    assign: { status: 400 }
  })

  return {
    /**
     * Test the reachability of the api.
     * @method ping
     * @param {string} [pong='pong'] - Pong message to return
     * @returns {string} - Pong message
     */
    ping (pong) {
      return co(function * () {
        return pong || 'pong'
      })
    },

    /**
     * @method signup
     * @param {string} key - User key to signup
     * @param {string} email - User email to signup
     * @param {string} password - User password to signup
     * @param {Object} [options={}] - Optional settings
     * @returns {Promise}
     */
    signup (key, email, password, options = {}) {
      const s = this
      let { provision, userAttr = {} } = options
      return co(function * () {
        validate('signup', { key, email, password })
        let proved = yield Promise.resolve(prove(provision))
        if (!proved) {
          throw signupProveError()
        }
        let user = yield User.create(Object.assign({ key, email }, userAttr))
        let hashSalt = digest.newSalt()
        let hash = yield digest(password, hashSalt)
        let signs = [
          { kind: 'key', key: key },
          { kind: 'email', key: email }
        ].filter((sign) => !!sign.key)
        for (let { kind, key } of signs) {
          yield UserSign.create({
            kind,
            key,
            hash,
            hashSalt,
            signupAt: new Date(),
            userId: user.id
          })
        }
        return s.signin(key, password)
      })
    },

    /**
     * Do sign in
     * @method signin
     * @param {string} key - User key or email to signup
     * @param {string} password - User password
     * @returns {Promise}
     */
    signin (key, password) {
      const s = this
      let { session } = s
      return co(function * () {
        validate('signin', { key, password })
        let userSign = yield UserSign.findOne({
          where: { key },
          include: [ UserSign.getRef('user') ]
        })
        if (!userSign) {
          throw signinFailError()
        }
        let hash = yield digest(password, userSign.hashSalt)
        let valid = hash === userSign.hash
        if (!valid) {
          throw signinFailError()
        }
        let { user } = userSign
        if (!user) {
          throw signInvalidError()
        }
        session.signed = define.formatSigned(user, userSign)
        return yield s.signget()
      })
    },

    /**
     * Get signing data
     * @method signget
     * @returns {Promise}
     */
    signget () {
      const s = this
      let { session } = s
      let { signed } = session
      return co(function * () {
        return signed
      })
    },

    /**
     * Modify sign data
     * @method signmod
     * @param {object} keys - Sign keys to update
     * @param {string} [password] - Password to update
     * @returns {Promise}
     */
    signmod (keys, password) {
      const s = this
      let { session } = s
      let { signed } = session
      if (!signed) {
        throw signinRequiredError()
      }
      let userId = signed.id
      return co(function * () {
        let user = yield User.findById(userId)
        for (let kind of Object.keys(keys)) {
          let value = keys[ kind ]
          let userSign = yield UserSign.findOne({
            where: { kind, userId }
          })

          let patch = { key: keys[ kind ] }
          if (password) {
            patch.hash = yield digest(password, userSign.hashSalt)
          }
          let changed = user[ kind ] !== value
          if (changed) {
            yield user.update({ [kind]: value })
          }
          userSign = yield userSign.update(patch)
          if (signed.sign.kind === kind) {
            signed.sign = userSign
          }
        }
        if (password) {
          let { kind } = signed.sign
          let value = keys[ kind ]
          return yield s.signin(value, password)
        } else {
          return yield s.signget()
        }
      })
    },

    /**
     * Do signout
     * @method signout
     * @returns {Promise}
     */
    signout () {
      const s = this
      let { session } = s
      return co(function * () {
        let { signed = {} } = session
        delete session.signed
        let { sign } = signed
        if (!sign) {
          return
        }
        let userSign = yield UserSign.findById(sign.id)
        if (!userSign) {
          return null
        }
        yield userSign.update({
          signoutAt: new Date()
        })
        return signed
      })
    },

    /**
     * Delete sign data
     * @method signdel
     * @returns {Promise}
     */
    signdel () {
      const s = this
      let { session } = s
      let { signed } = session
      let hasSign = signed && signed.hasOwnProperty('id')
      if (!hasSign) {
        throw signinRequiredError()
      }
      let { id: userId } = signed
      return co(function * () {
        let userSigns = yield UserSign.findAll({
          where: { userId }
        })
        for (let userSign of userSigns) {
          yield userSign.destroy()
        }
        let user = yield User.findById(userId)
        yield user.destroy()
        return s.signout()
      })
    },

    /**
     * Check password is valid
     * @method check
     * @param {string} password
     * @returns {Promise}
     */
    check (password) {
      const s = this
      let { session } = s
      return co(function * () {
        let { signed } = session
        let hasSign = signed && signed.hasOwnProperty('id')
        if (!hasSign) {
          throw signinRequiredError()
        }
        let { sign } = signed
        let hash = yield digest(password, sign.hashSalt)
        return hash === sign.hash
      })
    },

    /**
     * A hook which runs before method invoked
     * @param {string} methodName - Name of method to invoke
     * @param {Array} params - Prams for invocation
     * @returns {Promise}
     */
    $before (methodName, params) {
      const s = this
      let { session } = s
      if (!session) {
        throw new Error('Session not found. You need to add apeman-middleware-session to $middlewares.')
      }

      let { state } = s
      return co(function * () {
        state.invokedAt = new Date()
        logger.info(`${methodName} started...`)
      })
    },
    /**
     * A hook which runs after method invoked
     * @param {string} methodName - Name of method to invoke
     * @param {Array} params - Prams for invocation
     * @param {?*} returns - Return values
     * @returns {Promise}
     */
    $after (methodName, params, returns) {
      const s = this
      let { state } = s
      return co(function * () {
        let took = new Date() - state.invokedAt
        logger.info(`...${methodName} done! (${took}ms)`)
      })
    },
    /**
     * Method specifications
     */
    $spec: spec
  }
}

Object.assign(define, {
  formatSigned (user, userSign) {
    let sign = userSign.toJSON()
    delete sign.user
    return Object.assign({}, user.toJSON(), { sign })
  }
})

module.exports = define
