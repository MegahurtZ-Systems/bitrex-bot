/**
 * Define json schema resource.
 * @function apemanschema
 * @param {string} [dirname="schemas"] - Directory path which contains json schemas.
 * @param {Object} [options] - Optional settings.
 * @returns {Object.<string, ASchema>} - Schemas
 */

'use strict';

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var argx = require('argx');

var _require = require('stringcase'),
    pascalcase = _require.pascalcase;

var fromFiles = require('./validating/from_files');

/** @lends apemanschema */
function apemanschema(dirname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var args = argx(arguments);
  options = args.pop('object') || {};
  dirname = args.shift('string') || 'schemas';

  var validators = fromFiles(dirname);

  function schemas(name) {
    var keys = (0, _keys2.default)(validators);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var hit = pascalcase(key) === pascalcase(name) || pascalcase(key) === pascalcase(name) + 'Schema';
      if (hit) {
        return validators[key];
      }
    }
    var notfoundMsg = '[apemanschema] Unknown name "' + name + '".  (Available names are ' + (0, _stringify2.default)(keys) + ')';
    throw new Error(notfoundMsg);
  }

  (0, _assign2.default)(schemas, validators);

  schemas.toJSON = function () {
    var result = {};
    (0, _keys2.default)(validators).forEach(function (key) {
      result[key] = validators[key].toJSON();
    });
    return result;
  };

  return schemas;
}

module.exports = apemanschema;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwZW1hbnNjaGVtYS5qcyJdLCJuYW1lcyI6WyJhcmd4IiwicmVxdWlyZSIsInBhc2NhbGNhc2UiLCJmcm9tRmlsZXMiLCJhcGVtYW5zY2hlbWEiLCJkaXJuYW1lIiwib3B0aW9ucyIsImFyZ3MiLCJhcmd1bWVudHMiLCJwb3AiLCJzaGlmdCIsInZhbGlkYXRvcnMiLCJzY2hlbWFzIiwibmFtZSIsImtleXMiLCJpIiwibGVuZ3RoIiwia2V5IiwiaGl0Iiwibm90Zm91bmRNc2ciLCJFcnJvciIsInRvSlNPTiIsInJlc3VsdCIsImZvckVhY2giLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLE9BQU9DLFFBQVEsTUFBUixDQUFiOztlQUN1QkEsUUFBUSxZQUFSLEM7SUFBZkMsVSxZQUFBQSxVOztBQUNSLElBQU1DLFlBQVlGLFFBQVEseUJBQVIsQ0FBbEI7O0FBRUE7QUFDQSxTQUFTRyxZQUFULENBQXVCQyxPQUF2QixFQUE4QztBQUFBLE1BQWRDLE9BQWMsdUVBQUosRUFBSTs7QUFDNUMsTUFBSUMsT0FBT1AsS0FBS1EsU0FBTCxDQUFYO0FBQ0FGLFlBQVVDLEtBQUtFLEdBQUwsQ0FBUyxRQUFULEtBQXNCLEVBQWhDO0FBQ0FKLFlBQVVFLEtBQUtHLEtBQUwsQ0FBVyxRQUFYLEtBQXdCLFNBQWxDOztBQUVBLE1BQUlDLGFBQWFSLFVBQVVFLE9BQVYsQ0FBakI7O0FBRUEsV0FBU08sT0FBVCxDQUFrQkMsSUFBbEIsRUFBd0I7QUFDdEIsUUFBSUMsT0FBTyxvQkFBWUgsVUFBWixDQUFYO0FBQ0EsU0FBSyxJQUFJSSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELEtBQUtFLE1BQXpCLEVBQWlDRCxHQUFqQyxFQUFzQztBQUNwQyxVQUFJRSxNQUFNSCxLQUFNQyxDQUFOLENBQVY7QUFDQSxVQUFJRyxNQUFPaEIsV0FBV2UsR0FBWCxNQUFvQmYsV0FBV1csSUFBWCxDQUFyQixJQUEyQ1gsV0FBV2UsR0FBWCxNQUFvQmYsV0FBV1csSUFBWCxJQUFtQixRQUE1RjtBQUNBLFVBQUlLLEdBQUosRUFBUztBQUNQLGVBQU9QLFdBQVlNLEdBQVosQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxRQUFJRSxnREFBOENOLElBQTlDLGlDQUE4RSx5QkFBZUMsSUFBZixDQUE5RSxNQUFKO0FBQ0EsVUFBTSxJQUFJTSxLQUFKLENBQVVELFdBQVYsQ0FBTjtBQUNEOztBQUVELHdCQUFjUCxPQUFkLEVBQXVCRCxVQUF2Qjs7QUFFQUMsVUFBUVMsTUFBUixHQUFpQixZQUFZO0FBQzNCLFFBQUlDLFNBQVMsRUFBYjtBQUNBLHdCQUFZWCxVQUFaLEVBQXdCWSxPQUF4QixDQUFnQyxVQUFDTixHQUFELEVBQVM7QUFDdkNLLGFBQVFMLEdBQVIsSUFBZ0JOLFdBQVlNLEdBQVosRUFBa0JJLE1BQWxCLEVBQWhCO0FBQ0QsS0FGRDtBQUdBLFdBQU9DLE1BQVA7QUFDRCxHQU5EOztBQVFBLFNBQU9WLE9BQVA7QUFDRDs7QUFFRFksT0FBT0MsT0FBUCxHQUFpQnJCLFlBQWpCIiwiZmlsZSI6ImFwZW1hbnNjaGVtYS5qcyIsInNvdXJjZVJvb3QiOiJsaWIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlZmluZSBqc29uIHNjaGVtYSByZXNvdXJjZS5cbiAqIEBmdW5jdGlvbiBhcGVtYW5zY2hlbWFcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZGlybmFtZT1cInNjaGVtYXNcIl0gLSBEaXJlY3RvcnkgcGF0aCB3aGljaCBjb250YWlucyBqc29uIHNjaGVtYXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsIEFTY2hlbWE+fSAtIFNjaGVtYXNcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYXJneCA9IHJlcXVpcmUoJ2FyZ3gnKVxuY29uc3QgeyBwYXNjYWxjYXNlIH0gPSByZXF1aXJlKCdzdHJpbmdjYXNlJylcbmNvbnN0IGZyb21GaWxlcyA9IHJlcXVpcmUoJy4vdmFsaWRhdGluZy9mcm9tX2ZpbGVzJylcblxuLyoqIEBsZW5kcyBhcGVtYW5zY2hlbWEgKi9cbmZ1bmN0aW9uIGFwZW1hbnNjaGVtYSAoZGlybmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBhcmdzID0gYXJneChhcmd1bWVudHMpXG4gIG9wdGlvbnMgPSBhcmdzLnBvcCgnb2JqZWN0JykgfHwge31cbiAgZGlybmFtZSA9IGFyZ3Muc2hpZnQoJ3N0cmluZycpIHx8ICdzY2hlbWFzJ1xuXG4gIGxldCB2YWxpZGF0b3JzID0gZnJvbUZpbGVzKGRpcm5hbWUpXG5cbiAgZnVuY3Rpb24gc2NoZW1hcyAobmFtZSkge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXModmFsaWRhdG9ycylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzWyBpIF1cbiAgICAgIGxldCBoaXQgPSAocGFzY2FsY2FzZShrZXkpID09PSBwYXNjYWxjYXNlKG5hbWUpKSB8fCAocGFzY2FsY2FzZShrZXkpID09PSBwYXNjYWxjYXNlKG5hbWUpICsgJ1NjaGVtYScpXG4gICAgICBpZiAoaGl0KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzWyBrZXkgXVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbm90Zm91bmRNc2cgPSBgW2FwZW1hbnNjaGVtYV0gVW5rbm93biBuYW1lIFwiJHtuYW1lfVwiLiAgKEF2YWlsYWJsZSBuYW1lcyBhcmUgJHtKU09OLnN0cmluZ2lmeShrZXlzKX0pYFxuICAgIHRocm93IG5ldyBFcnJvcihub3Rmb3VuZE1zZylcbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oc2NoZW1hcywgdmFsaWRhdG9ycylcblxuICBzY2hlbWFzLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzdWx0ID0ge31cbiAgICBPYmplY3Qua2V5cyh2YWxpZGF0b3JzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHJlc3VsdFsga2V5IF0gPSB2YWxpZGF0b3JzWyBrZXkgXS50b0pTT04oKVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIHNjaGVtYXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcGVtYW5zY2hlbWFcbiJdfQ==