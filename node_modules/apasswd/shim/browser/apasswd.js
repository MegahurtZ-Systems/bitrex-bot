/**
 * Apeman password context.
 * @constructor APasswd
 * @param {object} config - Password configuration.
 * @param {string} [config.algorithm='pdkdf2'] - Name of algorithm.
 * @param {number} [config.iterations=100] - Iteration count.
 * @param {number} [config.length=84] - Key length.
 * @param {string} [config.format='base64'] - Digest format.
 */

'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _newSalt = require('./salting/new_salt');
var co = require('co');
var abind = require('abind');
var pdkdf2Digest = require('./digesting/pdkdf2_digest');

var _require = require('./constants'),
    DEFAULT_ALGORITHM = _require.DEFAULT_ALGORITHM,
    DEFAULT_ITERATIONS = _require.DEFAULT_ITERATIONS,
    DEFAULT_LENGTH = _require.DEFAULT_LENGTH,
    DEFAULT_FORMAT = _require.DEFAULT_FORMAT;

/** @lends APasswd */


function APasswd(config) {
  var s = this;
  (0, _assign2.default)(s, config);
  abind(s);
}

APasswd.prototype = {
  algorithm: DEFAULT_ALGORITHM,
  iterations: DEFAULT_ITERATIONS,
  length: DEFAULT_LENGTH,
  format: DEFAULT_FORMAT,
  /**
   * Digest a password.
   * @param {string} text - Text to digest.
   * @param {string} salt - Salt for digest.
   * @returns {Promise}
   */
  digest: function digest(text, salt) {
    var s = this;
    return co(_regenerator2.default.mark(function _callee() {
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = s.algorithm;
              _context.next = _context.t0 === 'pdkdf2' ? 3 : 6;
              break;

            case 3:
              _context.next = 5;
              return pdkdf2Digest(text, salt, {
                iterations: s.iterations,
                length: s.length,
                format: s.format
              });

            case 5:
              return _context.abrupt('return', _context.sent);

            case 6:
              throw new Error('Unknown algorithm: ' + s.algorithm);

            case 7:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  },

  /**
   * Generate a new salt.
   * @param {number} [len=8] - Salt length.
   * @returns {Promise.<string>} - New salt.
   */
  newSalt: function newSalt(len) {
    return _newSalt(len || 8);
  },

  /**
   * Get spec string.
   * @returns {string} spec - Spec of this password.
   */
  toSpecString: function toSpecString() {
    var s = this;
    return [s.algorithm, s.iterations, s.length].join(':');
  }
};

module.exports = APasswd;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwYXNzd2QuanMiXSwibmFtZXMiOlsibmV3U2FsdCIsInJlcXVpcmUiLCJjbyIsImFiaW5kIiwicGRrZGYyRGlnZXN0IiwiREVGQVVMVF9BTEdPUklUSE0iLCJERUZBVUxUX0lURVJBVElPTlMiLCJERUZBVUxUX0xFTkdUSCIsIkRFRkFVTFRfRk9STUFUIiwiQVBhc3N3ZCIsImNvbmZpZyIsInMiLCJwcm90b3R5cGUiLCJhbGdvcml0aG0iLCJpdGVyYXRpb25zIiwibGVuZ3RoIiwiZm9ybWF0IiwiZGlnZXN0IiwidGV4dCIsInNhbHQiLCJFcnJvciIsImxlbiIsInRvU3BlY1N0cmluZyIsImpvaW4iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxXQUFVQyxRQUFRLG9CQUFSLENBQWhCO0FBQ0EsSUFBTUMsS0FBS0QsUUFBUSxJQUFSLENBQVg7QUFDQSxJQUFNRSxRQUFRRixRQUFRLE9BQVIsQ0FBZDtBQUNBLElBQU1HLGVBQWVILFFBQVEsMkJBQVIsQ0FBckI7O2VBTUlBLFFBQVEsYUFBUixDO0lBSkZJLGlCLFlBQUFBLGlCO0lBQ0FDLGtCLFlBQUFBLGtCO0lBQ0FDLGMsWUFBQUEsYztJQUNBQyxjLFlBQUFBLGM7O0FBR0Y7OztBQUNBLFNBQVNDLE9BQVQsQ0FBa0JDLE1BQWxCLEVBQTBCO0FBQ3hCLE1BQU1DLElBQUksSUFBVjtBQUNBLHdCQUFjQSxDQUFkLEVBQWlCRCxNQUFqQjtBQUNBUCxRQUFNUSxDQUFOO0FBQ0Q7O0FBRURGLFFBQVFHLFNBQVIsR0FBb0I7QUFDbEJDLGFBQVdSLGlCQURPO0FBRWxCUyxjQUFZUixrQkFGTTtBQUdsQlMsVUFBUVIsY0FIVTtBQUlsQlMsVUFBUVIsY0FKVTtBQUtsQjs7Ozs7O0FBTUFTLFFBWGtCLGtCQVdWQyxJQVhVLEVBV0pDLElBWEksRUFXRTtBQUNsQixRQUFNUixJQUFJLElBQVY7QUFDQSxXQUFPVCw4QkFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNEJBQ0FTLEVBQUVFLFNBREY7QUFBQSw4Q0FFRCxRQUZDO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHFCQUdTVCxhQUFhYyxJQUFiLEVBQW1CQyxJQUFuQixFQUF5QjtBQUNwQ0wsNEJBQVlILEVBQUVHLFVBRHNCO0FBRXBDQyx3QkFBUUosRUFBRUksTUFGMEI7QUFHcENDLHdCQUFRTCxFQUFFSztBQUgwQixlQUF6QixDQUhUOztBQUFBO0FBQUE7O0FBQUE7QUFBQSxvQkFTRSxJQUFJSSxLQUFKLHlCQUFnQ1QsRUFBRUUsU0FBbEMsQ0FURjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFILEVBQVA7QUFZRCxHQXpCaUI7O0FBMEJsQjs7Ozs7QUFLQWIsU0EvQmtCLG1CQStCVHFCLEdBL0JTLEVBK0JKO0FBQ1osV0FBT3JCLFNBQVFxQixPQUFPLENBQWYsQ0FBUDtBQUNELEdBakNpQjs7QUFrQ2xCOzs7O0FBSUFDLGNBdENrQiwwQkFzQ0Y7QUFDZCxRQUFNWCxJQUFJLElBQVY7QUFDQSxXQUFPLENBQUVBLEVBQUVFLFNBQUosRUFBZUYsRUFBRUcsVUFBakIsRUFBNkJILEVBQUVJLE1BQS9CLEVBQXdDUSxJQUF4QyxDQUE2QyxHQUE3QyxDQUFQO0FBQ0Q7QUF6Q2lCLENBQXBCOztBQTRDQUMsT0FBT0MsT0FBUCxHQUFpQmhCLE9BQWpCIiwiZmlsZSI6ImFwYXNzd2QuanMiLCJzb3VyY2VSb290IjoibGliIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBcGVtYW4gcGFzc3dvcmQgY29udGV4dC5cbiAqIEBjb25zdHJ1Y3RvciBBUGFzc3dkXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0gUGFzc3dvcmQgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmFsZ29yaXRobT0ncGRrZGYyJ10gLSBOYW1lIG9mIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLml0ZXJhdGlvbnM9MTAwXSAtIEl0ZXJhdGlvbiBjb3VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxlbmd0aD04NF0gLSBLZXkgbGVuZ3RoLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuZm9ybWF0PSdiYXNlNjQnXSAtIERpZ2VzdCBmb3JtYXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5ld1NhbHQgPSByZXF1aXJlKCcuL3NhbHRpbmcvbmV3X3NhbHQnKVxuY29uc3QgY28gPSByZXF1aXJlKCdjbycpXG5jb25zdCBhYmluZCA9IHJlcXVpcmUoJ2FiaW5kJylcbmNvbnN0IHBka2RmMkRpZ2VzdCA9IHJlcXVpcmUoJy4vZGlnZXN0aW5nL3Bka2RmMl9kaWdlc3QnKVxuY29uc3Qge1xuICBERUZBVUxUX0FMR09SSVRITSxcbiAgREVGQVVMVF9JVEVSQVRJT05TLFxuICBERUZBVUxUX0xFTkdUSCxcbiAgREVGQVVMVF9GT1JNQVRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbi8qKiBAbGVuZHMgQVBhc3N3ZCAqL1xuZnVuY3Rpb24gQVBhc3N3ZCAoY29uZmlnKSB7XG4gIGNvbnN0IHMgPSB0aGlzXG4gIE9iamVjdC5hc3NpZ24ocywgY29uZmlnKVxuICBhYmluZChzKVxufVxuXG5BUGFzc3dkLnByb3RvdHlwZSA9IHtcbiAgYWxnb3JpdGhtOiBERUZBVUxUX0FMR09SSVRITSxcbiAgaXRlcmF0aW9uczogREVGQVVMVF9JVEVSQVRJT05TLFxuICBsZW5ndGg6IERFRkFVTFRfTEVOR1RILFxuICBmb3JtYXQ6IERFRkFVTFRfRk9STUFULFxuICAvKipcbiAgICogRGlnZXN0IGEgcGFzc3dvcmQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBkaWdlc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzYWx0IC0gU2FsdCBmb3IgZGlnZXN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGRpZ2VzdCAodGV4dCwgc2FsdCkge1xuICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICogKCkge1xuICAgICAgc3dpdGNoIChzLmFsZ29yaXRobSkge1xuICAgICAgICBjYXNlICdwZGtkZjInOlxuICAgICAgICAgIHJldHVybiB5aWVsZCBwZGtkZjJEaWdlc3QodGV4dCwgc2FsdCwge1xuICAgICAgICAgICAgaXRlcmF0aW9uczogcy5pdGVyYXRpb25zLFxuICAgICAgICAgICAgbGVuZ3RoOiBzLmxlbmd0aCxcbiAgICAgICAgICAgIGZvcm1hdDogcy5mb3JtYXRcbiAgICAgICAgICB9KVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhbGdvcml0aG06ICR7cy5hbGdvcml0aG19YClcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgc2FsdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW49OF0gLSBTYWx0IGxlbmd0aC5cbiAgICogQHJldHVybnMge1Byb21pc2UuPHN0cmluZz59IC0gTmV3IHNhbHQuXG4gICAqL1xuICBuZXdTYWx0IChsZW4pIHtcbiAgICByZXR1cm4gbmV3U2FsdChsZW4gfHwgOClcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBzcGVjIHN0cmluZy5cbiAgICogQHJldHVybnMge3N0cmluZ30gc3BlYyAtIFNwZWMgb2YgdGhpcyBwYXNzd29yZC5cbiAgICovXG4gIHRvU3BlY1N0cmluZyAoKSB7XG4gICAgY29uc3QgcyA9IHRoaXNcbiAgICByZXR1cm4gWyBzLmFsZ29yaXRobSwgcy5pdGVyYXRpb25zLCBzLmxlbmd0aCBdLmpvaW4oJzonKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQVBhc3N3ZFxuIl19